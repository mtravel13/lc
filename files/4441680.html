<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4441680.html">[LeetCode] Swap Nodes in Pairs 成对交换节点</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>&nbsp;</p>
<div class="question-description">
<div>
<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head.</p>
<p>Example:</p>
<pre>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</pre>
<p>Note:</p>
<ul>
<li>Your algorithm should use only constant extra space.</li>
<li>You may&nbsp;not&nbsp;modify the values in the list's nodes, only nodes itself may be changed.</li>
</ul>
</div>
</div>
<p>&nbsp;</p>
<p>这道题不算难，是基本的链表操作题，我们可以分别用递归和迭代来实现。对于迭代实现，还是需要建立dummy节点，注意在连接节点的时候，最好画个图，以免把自己搞晕了，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* swapPairs(ListNode*<span style="color: #000000;"> head) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span>), *pre =<span style="color: #000000;"> dummy;
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;<span style="color: #000000;">next) {
            ListNode </span>*t = pre-&gt;next-&gt;<span style="color: #000000;">next;
            pre</span>-&gt;next-&gt;next = t-&gt;<span style="color: #000000;">next;
            t</span>-&gt;next = pre-&gt;<span style="color: #000000;">next;
            pre</span>-&gt;next =<span style="color: #000000;"> t;
            pre </span>= t-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>递归的写法就更简洁了，实际上利用了回溯的思想，递归遍历到链表末尾，然后先交换末尾两个，然后依次往前交换：</p>
<p>&nbsp;</p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* swapPairs(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*t = head-&gt;<span style="color: #000000;">next;
        head</span>-&gt;next = swapPairs(head-&gt;next-&gt;<span style="color: #000000;">next);
        t</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4441324.html" target="_blank">Reverse Nodes in k-Group</a></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/problems/swap-nodes-in-pairs" target="_blank">https://leetcode.com/problems/swap-nodes-in-pairs</a></p>
<p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11030/My-accepted-java-code.-used-recursion.">https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11030/My-accepted-java-code.-used-recursion.</a></p>
<p>&nbsp;</p>
<p><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
