<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4392254.html">[LeetCode] Binary Tree Right Side View 二叉树的右侧视图</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>&nbsp;</p>
<p>Given a binary tree, imagine yourself standing on the&nbsp;<em>right</em>&nbsp;side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br />Given the following binary tree,</p>
<pre>   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</pre>
<p>&nbsp;</p>
<p>You should return&nbsp;<code>[1, 3, 4]</code>.</p>
<p>Credits:<br />Special thanks to&nbsp;<a href="https://leetcode.com/discuss/user/amrsaqr">@amrsaqr</a>&nbsp;for adding this problem and creating all test cases.</p>
<p>&nbsp;</p>
<p>这道题要求我们打印出二叉树每一行最右边的一个数字，实际上是求二叉树层序遍历的一种变形，我们只需要保存每一层最右边的数字即可，可以参考我之前的博客<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4051321.html">&nbsp;Binary Tree Level Order Traversal 二叉树层序遍历</a>，这道题只要在之前那道题上稍加修改即可得到结果，还是需要用到数据结构队列queue，遍历每层的节点时，把下一层的节点都存入到queue中，每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中，代码如下：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; rightSideView(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            res.push_back(q.back()</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; size; ++<span style="color: #000000;">i) {
                TreeNode </span>*node =<span style="color: #000000;"> q.front();
                q.pop();
                </span><span style="color: #0000ff;">if</span> (node-&gt;left) q.push(node-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (node-&gt;right) q.push(node-&gt;<span style="color: #000000;">right);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
